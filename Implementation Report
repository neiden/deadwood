The primary design patterns I used for this project was MVC and Observer. I initially tried to create the GUI without applying these patterns and immediately found it difficult to make classes interact in a meaningful way. First I created a MVC system which allowed for an ease of testing functionality and simplification of the code. Allowing for the Controller to be the only bridge between the model and view meant that those pieces could create methods independent of the knowledge of the other. This was particularly important for updating the old code to be compatible with the graphical components; the task was simplified to consolidating the data of the game into the model so that the view would simply reflect the state of the game, which I know already worked from the prior assignment. Once that had been put into place, the Observer made a lot of sense to implement as it meant that the controller could define the behavior of the graphical components while the view could simply create them. I had the view contain an update method to set the graphics to correspond to the data while the controller defined behavior of the buttons would listen for an event to occur to see if they had been called. The project's structure eventually had all of the previous code as the model, so creating the finished product only involved removing text based input and replacing them with button based events. 
To accomodate the dynamic graphical elements of the game (scenes, player icons, shot counters), I added ImageViews to the classes that were being represented so that they corresponded to those objects. For example, having the player icon be updated whenever a movement occurred, or having the card on the scene flip over when the shot counters reached 0. Having the ImageViews attached to the corrseponding objects made making all the pieces change dynamically very easy as their data already had been doing that to begin with. 